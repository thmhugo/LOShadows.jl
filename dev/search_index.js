var documenterSearchIndex = {"docs":
[{"location":"applications/Binning/#Binned-probabilities","page":"Binned probabilities","title":"Binned probabilities","text":"","category":"section"},{"location":"applications/Binning/#LOShadows.binned_probability-Tuple{Vector{Int64}, Vector{Vector{Int64}}, DensityMatrixBlock}","page":"Binned probabilities","title":"LOShadows.binned_probability","text":"binned_probability(k::Vector{Int}, bins::Vector{Vector{Int}}, ρ::DensityMatrixBlock)\n\nCompute the probability of observing the occupation k =k_1 cdots k_textbins when the output bins are given by bins.\n\n\n\n\n\n","category":"method"},{"location":"functions/Channels/#SU(m)-irreps-projectors","page":"SU(m) irreps projectors","title":"SU(m) irreps projectors","text":"","category":"section"},{"location":"functions/Channels/#LOShadows.projection_matrices-Tuple{Int64, Int64}","page":"SU(m) irreps projectors","title":"LOShadows.projection_matrices","text":"projection_matrices(m::Int, n::Int; load_from_memory = true, save_in_memory = true, infer_last::Bool = true)\n\nCompute projection matrices for m and all i ≤ n and 0 ≤ k ≤ i.\n\nSerialize computed matrix.\n\nDeserialize data on disk when found.\n\nnote: Note\nThe implementation supports multithreading with julia -t <num_threads>.\n\nwarning: Warning\nAs of today, the implementation only supports the computation of the projectors involving the totally symmetric irrep of SU(m) and its dual.\n\n\n\n\n\n","category":"method"},{"location":"functions/Channels/#LOShadows.linearised_fock_basis_indices-Tuple{Int64, Int64}","page":"SU(m) irreps projectors","title":"LOShadows.linearised_fock_basis_indices","text":"linearised_fock_basis_indices(m::Int, n::Int)\n\nIndexes the linearised Fock basis used for the projection matrices.\n\n\n\n\n\n","category":"method"},{"location":"functions/FockOperators/#FockOperators","page":"FockOperators","title":"FockOperators","text":"","category":"section"},{"location":"functions/FockOperators/#LOShadows.Eij","page":"FockOperators","title":"LOShadows.Eij","text":"Eij(m::Int, n::Int, i::Int, j::Int)\n\nFinite dimensional matrix representation of the operator E_ij = hata_i^dagger hata_j acting over mathcalH_m^n.\n\n\n\n\n\n","category":"function"},{"location":"functions/FockOperators/#LOShadows.Ozj","page":"FockOperators","title":"LOShadows.Ozj","text":"Ozj(m::Int, n::Int, j::Int)\n\nFinite dimensional matrix representation of the number operator O^z_j = hatn_j acting over mathcalH_m^n.\n\n\n\n\n\n","category":"function"},{"location":"functions/FockOperators/#LOShadows.Oxjk","page":"FockOperators","title":"LOShadows.Oxjk","text":"Oxjk(m::Int, n::Int, j::Int, k::Int)\n\nFinite dimensional matrix representation of the operator O^x_jk = frac1sqrt2(E_jk + E_kj) acting over mathcalH_m^n.\n\n\n\n\n\n","category":"function"},{"location":"functions/FockOperators/#LOShadows.Oyjk","page":"FockOperators","title":"LOShadows.Oyjk","text":"Oyjk(m::Int, n::Int, j::Int, k::Int)\n\nFinite dimensional matrix representation of the operator O^y_jk = fracimathsqrt2(E_jk - E_kj) acting over mathcalH_m^n.\n\n\n\n\n\n","category":"function"},{"location":"functions/MatrixOperations/#MatrixOperations","page":"MatrixOperations","title":"MatrixOperations","text":"","category":"section"},{"location":"functions/MatrixOperations/#LOShadows.direct_sum","page":"MatrixOperations","title":"LOShadows.direct_sum","text":"direct_sum(A::Matrix{<:Number}, B::Matrix{<:Number})\n\nCompute the direct sum A oplus B\n\n\n\n\n\ndirect_sum(M::Vector{Matrix{T}} where T <: Number)\n\nWrapper of direct_sum(A::Matrix{<:Number}, B::Matrix{<:Number}) for a list of matrices, e.g., for M = [A, B, C, ...] returns A oplus B oplus C oplus cdots.\n\n\n\n\n\n","category":"function"},{"location":"functions/MatrixOperations/#LOShadows.sparse_sym_mvp","page":"MatrixOperations","title":"LOShadows.sparse_sym_mvp","text":"sparse_sym_mvp(A::SparseMatrixCSC{Float64, Int64}, x::Vector{<:Number})\n\nImplementation of the sparse-matrix vector product Ax when A is symmetric and given via its upper-triangular form.\n\n\n\n\n\nsparse_sym_mvp(A::SparseMatrixCSC{Float64, Int64}, x::DensityVectorBlock)\n\n\n\n\n\n","category":"function"},{"location":"usage/shadows/#Classical-shadows","page":"Classical shadows","title":"Classical shadows","text":"","category":"section"},{"location":"usage/shadows/","page":"Classical shadows","title":"Classical shadows","text":"See this notebook for a detailed example of the protocol using Perceval.","category":"page"},{"location":"applications/Invariants/#Linear-Optical-Lie-algebraic-invariants","page":"Linear Optical Lie-algebraic invariants","title":"Linear Optical Lie-algebraic invariants","text":"","category":"section"},{"location":"applications/Invariants/#LOShadows.linear_invariant-Tuple{DensityMatrixBlock}","page":"Linear Optical Lie-algebraic invariants","title":"LOShadows.linear_invariant","text":"linear_invariant(ρ::DensityMatrixBlock)\n\nComputes the linear optical Lie-algebraic invariant I_2 (Eq.(14) of this reference).\n\n\n\n\n\n","category":"method"},{"location":"applications/Invariants/#LOShadows.covariance_invariant-Tuple{DensityMatrixBlock}","page":"Linear Optical Lie-algebraic invariants","title":"LOShadows.covariance_invariant","text":"covariance_invariant(ρ::DensityMatrixBlock)\n\nComputes the covariance invariant (Eq.(9) of this reference).\n\n\n\n\n\n","category":"method"},{"location":"applications/Invariants/#LOShadows.tangent_invariant-Tuple{DensityMatrixBlock}","page":"Linear Optical Lie-algebraic invariants","title":"LOShadows.tangent_invariant","text":"tangent_invariant(ρ::DensityMatrixBlock)\n\nComputes the tangent invariant (Eq.(20) of this reference).\n\n\n\n\n\n","category":"method"},{"location":"#LOShadow.jl","page":"LOShadow.jl","title":"LOShadow.jl","text":"","category":"section"},{"location":"","page":"LOShadow.jl","title":"LOShadow.jl","text":"This package provides an implementation of the classical shadow protocol for linear optics, as introduced in Thomas, H., Chabaud, U., & Emeriau, P. E. (2025). Shedding light on classical shadows: learning photonic quantum states.","category":"page"},{"location":"types/DensityMatrix/#DensityMatrix","page":"DensityMatrix","title":"DensityMatrix","text":"","category":"section"},{"location":"types/DensityMatrix/#LOShadows.DensityMatrix","page":"DensityMatrix","title":"LOShadows.DensityMatrix","text":"DensityMatrix(m::Int, n::Int, ρ::Matrix{ComplexF64})\nDensityMatrix(m::Int, n::Int, blocks::Vector{Matrix{ComplexF64}})\n\nStores the density matrix of an m-mode Fock state with at most n photons.\n\n\n\n\n\n","category":"type"},{"location":"types/DensityMatrix/#LOShadows.DensityMatrixBlock","page":"DensityMatrix","title":"LOShadows.DensityMatrixBlock","text":"DensityMatrixBlock(m::Int, n::Int, ρ::Matrix{ComplexF64})\n\nStores the density matrix of an m-mode, n-photon Fock state restricted to the n-photon sector.\n\n\n\n\n\n","category":"type"},{"location":"types/DensityMatrix/#LOShadows.DensityVectorBlock","page":"DensityMatrix","title":"LOShadows.DensityVectorBlock","text":"DensityVectorBlock(m::Int, n::Int, ρ::Matrix{ComplexF64})\n\nStores the density matrix of an m-mode, n-photon Fock state restricted to the n-photon sector in vectorised form.\n\n\n\n\n\n","category":"type"},{"location":"types/DensityMatrix/#LOShadows.linearise-Tuple{DensityMatrixBlock}","page":"DensityMatrix","title":"LOShadows.linearise","text":"linearise(ρ::DensityMatrixBlock)\n\nLinearise a d times d density matrix block (in mathcalH_m^n), where d = binomn+m-1n, to a d^2-dimensional DensityVectorBlock.\n\n\n\n\n\n","category":"method"},{"location":"types/DensityMatrix/#LOShadows.extract_blocks-Tuple{DensityMatrix}","page":"DensityMatrix","title":"LOShadows.extract_blocks","text":"extract_blocks(ρ::DensityMatrix)\n\nExtracts the block corresponding to each photon sectors.\n\n\n\n\n\n","category":"method"},{"location":"types/DensityMatrix/#LOShadows.apply_channel-Tuple{DensityMatrix, Any}","page":"DensityMatrix","title":"LOShadows.apply_channel","text":"apply_channel(ρ::DensityMatrix, Π)\n\nApply the channel Π to rho, i.e., returns M(rho) where Π is the matrix form of the channel M.\n\n\n\n\n\n","category":"method"},{"location":"types/DensityMatrix/#LOShadows.apply_nth_channel-Tuple{DensityMatrixBlock, Any}","page":"DensityMatrix","title":"LOShadows.apply_nth_channel","text":"apply_nth_channel(ρ::DensityMatrix, Π)\n\nApply the channel Π to the n-photon sector rho^(n),i.e., returns M^(n)(rho^(n)) where Π is the matrix form of the channel M.\n\n\n\n\n\n","category":"method"},{"location":"usage/projectors/#Computing-projectors-onto-irreps-of-\\omega_mn","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"","category":"section"},{"location":"usage/projectors/#Compute-projectors","page":"Computing projectors onto irreps of omega_m^n","title":"Compute projectors","text":"","category":"section"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"Use projection_matrices to compute the projection matrices. It will store them in memory at the end and fetch those you already computed. It will create a directory projectors/ to store projectors locally.","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"Π = projection_matrices(m, n)","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"It will compute all projectors for m modes and up to n photons. Π is a hashmap [m, n, k] => SparseMatrixCSC{Float32, Int64}. For instance for 3 modes and 2 photons:","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"Start by enabling debugging messages with using Logging; global_logger(ConsoleLogger(stdout,Logging.Debug)).","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"julia> Π = projection_matrices(3,2)\n Debug: Infer Last one\n└ @ Main.Channels .../Channels.jl:292\n┌ Debug: m=3 n=0 computed projectors \n└ @ Main.Channels .../Channels.jl:300\n┌ Debug: m3-n0 saved at\n│   path = \"./projectors/P-m3-n0\"\n└ @ Main.Channels .../Channels.jl:308\n┌ Debug: Compute GC m = 3, n = 1, k = 0\n└ @ Main.Channels .../Channels.jl:75\n┌ Debug: Infer Last one\n└ @ Main.Channels .../Channels.jl:292\n┌ Debug: m=3 n=1 computed projectors \n└ @ Main.Channels .../Channels.jl:300\n┌ Debug: m3-n1 saved at\n│   path = \"./projectors/P-m3-n1\"\n└ @ Main.Channels .../Channels.jl:308\n┌ Debug: Compute GC m = 3, n = 2, k = 0\n└ @ Main.Channels .../Channels.jl:75\n┌ Debug: Compute GC m = 3, n = 2, k = 1\n└ @ Main.Channels .../Channels.jl:75\n┌ Debug: Infer Last one\n└ @ Main.Channels .../Channels.jl:292\n┌ Debug: m=3 n=2 computed projectors \n└ @ Main.Channels .../Channels.jl:300\n┌ Debug: m3-n2 saved at\n│   path = \"./projectors/P-m3-n2\"\n└ @ Main.Channels .../Channels.jl:308\nDict{Any, Any} with 6 entries:\n  [3, 2, 1] => sparse([1, 2, 3, 7, 1, 8, 9, 2, 10, 3  …  33, 14, 28, 35, 1, 8, 15, 22, 29, 36], [1, 2, 3, 7, 8, 8, 9…\n  [3, 1, 1] => sparse([1, 2, 3, 4, 1, 5, 6, 7, 8, 1, 5, 9], [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 9, 9], [0.666667, 1.0, 1.…\n  [3, 2, 0] => sparse([1, 1, 8, 1, 8, 15, 1, 8, 15, 22  …  8, 15, 22, 29, 1, 8, 15, 22, 29, 36], [1, 8, 8, 15, 15, 1…\n  [3, 1, 0] => sparse([1, 1, 5, 1, 5, 9], [1, 5, 5, 9, 9, 9], Float32[0.333333, 0.333333, 0.333333, 0.333333, 0.3333…\n  [3, 2, 2] => sparse([1, 2, 3, 4, 5, 6, 7, 1, 8, 9  …  34, 14, 28, 35, 1, 8, 15, 22, 29, 36], [1, 2, 3, 4, 5, 6, 7,…\n  [3, 0, 0] => sparse([1], [1], [1.0], 1, 1)","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"All the projectors for less that 2 photons in 3 modes are computed, and for each of them, k ranges from 0 to n. The projectors to the k-th irrep of the n-photon state is accessed via Π[[m, n, k]] (notice that the hashmap's key is a list). The storage format is detailed below.","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"If save_in_memory is set to true, the function call will create the files:","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"projectors/P-m3-n0\nprojectors/P-m3-n1\nprojectors/P-m3-n2","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"so that another call with now 3 photons displays","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"julia> Π = projection_matrices(3, 3)\n┌ Debug: m=3 n=0 loaded from memory \n└ @ Main.Channels .../Channels.jl:281\n┌ Debug: m=3 n=1 loaded from memory \n└ @ Main.Channels .../Channels.jl:281\n┌ Debug: m=3 n=2 loaded from memory \n└ @ Main.Channels .../Channels.jl:281\n┌ Debug: Compute GC m = 3, n = 3, k = 0\n└ @ Main.Channels .../Channels.jl:75\n┌ Debug: loaded CGC from disk: Irrep[SU₃](\"10⁺\") ⊗ Irrep[SU₃](\"10\") → Irrep[SU₃](\"1\")\n└ @ SUNRepresentations .../caching.jl:23\n┌ Debug: Compute GC m = 3, n = 3, k = 1\n└ @ Main.Channels .../Channels.jl:75\n┌ Debug: loaded CGC from disk: Irrep[SU₃](\"10⁺\") ⊗ Irrep[SU₃](\"10\") → Irrep[SU₃](\"8\")\n└ @ SUNRepresentations .../caching.jl:23\n┌ Debug: Compute GC m = 3, n = 3, k = 2\n└ @ Main.Channels .../Channels.jl:75\n┌ Debug: loaded CGC from disk: Irrep[SU₃](\"10⁺\") ⊗ Irrep[SU₃](\"10\") → Irrep[SU₃](\"27\")\n└ @ SUNRepresentations .../caching.jl:23\n┌ Debug: Infer Last one\n└ @ Main.Channels .../Channels.jl:292\n┌ Debug: m=3 n=3 computed projectors \n└ @ Main.Channels .../Channels.jl:300\n┌ Debug: m3-n3 saved at\n│   path = \"./projectors/P-m3-n3\"\n└ @ Main.Channels .../Channels.jl:308\nDict{Any, Any} with 10 entries:\n  [3, 2, 1] => sparse([1, 2, 3, 7, 1, 8, 9, 2, 10, 3  …  33, 14, 28, 35, 1, 8, 15, 22, 29, 36], [1, 2, 3, 7, 8, 8, 9…\n  [3, 1, 1] => sparse([1, 2, 3, 4, 1, 5, 6, 7, 8, 1, 5, 9], [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 9, 9], [0.666667, 1.0, 1.…\n  [3, 2, 0] => sparse([1, 1, 8, 1, 8, 15, 1, 8, 15, 22  …  8, 15, 22, 29, 1, 8, 15, 22, 29, 36], [1, 8, 8, 15, 15, 1…\n  [3, 1, 0] => sparse([1, 1, 5, 1, 5, 9], [1, 5, 5, 9, 9, 9], Float32[0.333333, 0.333333, 0.333333, 0.333333, 0.3333…\n  [3, 3, 3] => sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  1, 12, 23, 34, 45, 56, 67, 78, 89, 100], [1, 2, 3, 4, 5, 6,…\n  [3, 2, 2] => sparse([1, 2, 3, 4, 5, 6, 7, 1, 8, 9  …  34, 14, 28, 35, 1, 8, 15, 22, 29, 36], [1, 2, 3, 4, 5, 6, 7,…\n  [3, 3, 1] => sparse([1, 2, 3, 11, 1, 12, 13, 2, 14, 3  …  77, 88, 99, 1, 12, 34, 56, 67, 89, 100], [1, 2, 3, 11, 1…\n  [3, 3, 0] => sparse([1, 1, 12, 1, 12, 23, 1, 12, 23, 34  …  1, 12, 23, 34, 45, 56, 67, 78, 89, 100], [1, 12, 12, 2…\n  [3, 3, 2] => sparse([1, 2, 3, 4, 5, 6, 11, 1, 12, 13  …  1, 12, 23, 34, 45, 56, 67, 78, 89, 100], [1, 2, 3, 4, 5, …\n  [3, 0, 0] => sparse([1], [1], [1.0], 1, 1)","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"and the following file is created:","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"projectors/P-m3-n3","category":"page"},{"location":"usage/projectors/#Usage-of-the-projectors","page":"Computing projectors onto irreps of omega_m^n","title":"Usage of the projectors","text":"","category":"section"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"The projectors are stored in Sparse (CSC) format. As they are symmetric, only the upper triangular part is stored:","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"julia> Π = projection_matrices(2,2)\njulia> Π[[2,2,2]]\n9×9 SparseMatrixCSC{Float32, Int64} with 14 stored entries:\n 0.166667   ⋅    ⋅    ⋅   -0.333333    ⋅    ⋅     ⋅    0.166667\n  ⋅        0.5   ⋅    ⋅     ⋅        -0.5   ⋅     ⋅     ⋅ \n  ⋅         ⋅   1.0   ⋅     ⋅          ⋅    ⋅     ⋅     ⋅ \n  ⋅         ⋅    ⋅   0.5    ⋅          ⋅    ⋅   -0.5    ⋅ \n  ⋅         ⋅    ⋅    ⋅    0.666667    ⋅    ⋅     ⋅   -0.333333\n  ⋅         ⋅    ⋅    ⋅     ⋅         0.5   ⋅     ⋅     ⋅ \n  ⋅         ⋅    ⋅    ⋅     ⋅          ⋅   1.0    ⋅     ⋅ \n  ⋅         ⋅    ⋅    ⋅     ⋅          ⋅    ⋅    0.5    ⋅ \n  ⋅         ⋅    ⋅    ⋅     ⋅          ⋅    ⋅     ⋅    0.166667","category":"page"},{"location":"usage/projectors/","page":"Computing projectors onto irreps of omega_m^n","title":"Computing projectors onto irreps of omega_m^n","text":"We provide a helper function sparse_sym_mvp(A, x) that performs the matrix-vector multiplication Ax by keeping A in sparse and upper-triangular format.","category":"page"}]
}
